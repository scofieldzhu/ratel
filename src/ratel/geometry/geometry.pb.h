// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: geometry.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_geometry_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_geometry_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include "ratel/geometry/geometry_export.h"
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_geometry_2eproto RATEL_GEOMETRY_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct RATEL_GEOMETRY_API TableStruct_geometry_2eproto {
  static const uint32_t offsets[];
};
RATEL_GEOMETRY_API extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_geometry_2eproto;
namespace ratel {
class CircleF;
struct CircleFDefaultTypeInternal;
RATEL_GEOMETRY_API extern CircleFDefaultTypeInternal _CircleF_default_instance_;
class CircleI;
struct CircleIDefaultTypeInternal;
RATEL_GEOMETRY_API extern CircleIDefaultTypeInternal _CircleI_default_instance_;
class Line2F;
struct Line2FDefaultTypeInternal;
RATEL_GEOMETRY_API extern Line2FDefaultTypeInternal _Line2F_default_instance_;
class Line2I;
struct Line2IDefaultTypeInternal;
RATEL_GEOMETRY_API extern Line2IDefaultTypeInternal _Line2I_default_instance_;
class Poly2F;
struct Poly2FDefaultTypeInternal;
RATEL_GEOMETRY_API extern Poly2FDefaultTypeInternal _Poly2F_default_instance_;
class Poly2I;
struct Poly2IDefaultTypeInternal;
RATEL_GEOMETRY_API extern Poly2IDefaultTypeInternal _Poly2I_default_instance_;
class RectF;
struct RectFDefaultTypeInternal;
RATEL_GEOMETRY_API extern RectFDefaultTypeInternal _RectF_default_instance_;
class RectI;
struct RectIDefaultTypeInternal;
RATEL_GEOMETRY_API extern RectIDefaultTypeInternal _RectI_default_instance_;
class SizeF;
struct SizeFDefaultTypeInternal;
RATEL_GEOMETRY_API extern SizeFDefaultTypeInternal _SizeF_default_instance_;
class SizeI;
struct SizeIDefaultTypeInternal;
RATEL_GEOMETRY_API extern SizeIDefaultTypeInternal _SizeI_default_instance_;
class Vec2F;
struct Vec2FDefaultTypeInternal;
RATEL_GEOMETRY_API extern Vec2FDefaultTypeInternal _Vec2F_default_instance_;
class Vec2I;
struct Vec2IDefaultTypeInternal;
RATEL_GEOMETRY_API extern Vec2IDefaultTypeInternal _Vec2I_default_instance_;
class Vec2fList;
struct Vec2fListDefaultTypeInternal;
RATEL_GEOMETRY_API extern Vec2fListDefaultTypeInternal _Vec2fList_default_instance_;
class Vec3F;
struct Vec3FDefaultTypeInternal;
RATEL_GEOMETRY_API extern Vec3FDefaultTypeInternal _Vec3F_default_instance_;
class Vec3I;
struct Vec3IDefaultTypeInternal;
RATEL_GEOMETRY_API extern Vec3IDefaultTypeInternal _Vec3I_default_instance_;
}  // namespace ratel
PROTOBUF_NAMESPACE_OPEN
template<> RATEL_GEOMETRY_API ::ratel::CircleF* Arena::CreateMaybeMessage<::ratel::CircleF>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::CircleI* Arena::CreateMaybeMessage<::ratel::CircleI>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::Line2F* Arena::CreateMaybeMessage<::ratel::Line2F>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::Line2I* Arena::CreateMaybeMessage<::ratel::Line2I>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::Poly2F* Arena::CreateMaybeMessage<::ratel::Poly2F>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::Poly2I* Arena::CreateMaybeMessage<::ratel::Poly2I>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::RectF* Arena::CreateMaybeMessage<::ratel::RectF>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::RectI* Arena::CreateMaybeMessage<::ratel::RectI>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::SizeF* Arena::CreateMaybeMessage<::ratel::SizeF>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::SizeI* Arena::CreateMaybeMessage<::ratel::SizeI>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::Vec2F* Arena::CreateMaybeMessage<::ratel::Vec2F>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::Vec2I* Arena::CreateMaybeMessage<::ratel::Vec2I>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::Vec2fList* Arena::CreateMaybeMessage<::ratel::Vec2fList>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::Vec3F* Arena::CreateMaybeMessage<::ratel::Vec3F>(Arena*);
template<> RATEL_GEOMETRY_API ::ratel::Vec3I* Arena::CreateMaybeMessage<::ratel::Vec3I>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ratel {

// ===================================================================

class RATEL_GEOMETRY_API Vec2F final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.Vec2F) */ {
 public:
  inline Vec2F() : Vec2F(nullptr) {}
  ~Vec2F() override;
  explicit PROTOBUF_CONSTEXPR Vec2F(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec2F(const Vec2F& from);
  Vec2F(Vec2F&& from) noexcept
    : Vec2F() {
    *this = ::std::move(from);
  }

  inline Vec2F& operator=(const Vec2F& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2F& operator=(Vec2F&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec2F& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec2F* internal_default_instance() {
    return reinterpret_cast<const Vec2F*>(
               &_Vec2F_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vec2F& a, Vec2F& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2F* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2F* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec2F* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec2F>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec2F& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec2F& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2F* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.Vec2F";
  }
  protected:
  explicit Vec2F(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:ratel.Vec2F)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API Vec2fList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.Vec2fList) */ {
 public:
  inline Vec2fList() : Vec2fList(nullptr) {}
  ~Vec2fList() override;
  explicit PROTOBUF_CONSTEXPR Vec2fList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec2fList(const Vec2fList& from);
  Vec2fList(Vec2fList&& from) noexcept
    : Vec2fList() {
    *this = ::std::move(from);
  }

  inline Vec2fList& operator=(const Vec2fList& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2fList& operator=(Vec2fList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec2fList& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec2fList* internal_default_instance() {
    return reinterpret_cast<const Vec2fList*>(
               &_Vec2fList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vec2fList& a, Vec2fList& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2fList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2fList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec2fList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec2fList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec2fList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec2fList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2fList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.Vec2fList";
  }
  protected:
  explicit Vec2fList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 1,
  };
  // repeated .ratel.Vec2F list = 1;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::ratel::Vec2F* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2F >*
      mutable_list();
  private:
  const ::ratel::Vec2F& _internal_list(int index) const;
  ::ratel::Vec2F* _internal_add_list();
  public:
  const ::ratel::Vec2F& list(int index) const;
  ::ratel::Vec2F* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2F >&
      list() const;

  // @@protoc_insertion_point(class_scope:ratel.Vec2fList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2F > list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API Vec2I final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.Vec2I) */ {
 public:
  inline Vec2I() : Vec2I(nullptr) {}
  ~Vec2I() override;
  explicit PROTOBUF_CONSTEXPR Vec2I(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec2I(const Vec2I& from);
  Vec2I(Vec2I&& from) noexcept
    : Vec2I() {
    *this = ::std::move(from);
  }

  inline Vec2I& operator=(const Vec2I& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2I& operator=(Vec2I&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec2I& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec2I* internal_default_instance() {
    return reinterpret_cast<const Vec2I*>(
               &_Vec2I_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vec2I& a, Vec2I& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2I* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2I* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec2I* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec2I>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec2I& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec2I& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2I* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.Vec2I";
  }
  protected:
  explicit Vec2I(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ratel.Vec2I)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t x_;
  int32_t y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API Vec3F final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.Vec3F) */ {
 public:
  inline Vec3F() : Vec3F(nullptr) {}
  ~Vec3F() override;
  explicit PROTOBUF_CONSTEXPR Vec3F(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec3F(const Vec3F& from);
  Vec3F(Vec3F&& from) noexcept
    : Vec3F() {
    *this = ::std::move(from);
  }

  inline Vec3F& operator=(const Vec3F& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3F& operator=(Vec3F&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3F& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3F* internal_default_instance() {
    return reinterpret_cast<const Vec3F*>(
               &_Vec3F_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Vec3F& a, Vec3F& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3F* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3F* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3F* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec3F>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec3F& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec3F& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3F* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.Vec3F";
  }
  protected:
  explicit Vec3F(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:ratel.Vec3F)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API Vec3I final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.Vec3I) */ {
 public:
  inline Vec3I() : Vec3I(nullptr) {}
  ~Vec3I() override;
  explicit PROTOBUF_CONSTEXPR Vec3I(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec3I(const Vec3I& from);
  Vec3I(Vec3I&& from) noexcept
    : Vec3I() {
    *this = ::std::move(from);
  }

  inline Vec3I& operator=(const Vec3I& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3I& operator=(Vec3I&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3I& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3I* internal_default_instance() {
    return reinterpret_cast<const Vec3I*>(
               &_Vec3I_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Vec3I& a, Vec3I& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3I* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3I* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3I* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec3I>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec3I& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec3I& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3I* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.Vec3I";
  }
  protected:
  explicit Vec3I(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // int32 z = 3;
  void clear_z();
  int32_t z() const;
  void set_z(int32_t value);
  private:
  int32_t _internal_z() const;
  void _internal_set_z(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ratel.Vec3I)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t x_;
  int32_t y_;
  int32_t z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API SizeI final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.SizeI) */ {
 public:
  inline SizeI() : SizeI(nullptr) {}
  ~SizeI() override;
  explicit PROTOBUF_CONSTEXPR SizeI(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SizeI(const SizeI& from);
  SizeI(SizeI&& from) noexcept
    : SizeI() {
    *this = ::std::move(from);
  }

  inline SizeI& operator=(const SizeI& from) {
    CopyFrom(from);
    return *this;
  }
  inline SizeI& operator=(SizeI&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SizeI& default_instance() {
    return *internal_default_instance();
  }
  static inline const SizeI* internal_default_instance() {
    return reinterpret_cast<const SizeI*>(
               &_SizeI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SizeI& a, SizeI& b) {
    a.Swap(&b);
  }
  inline void Swap(SizeI* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SizeI* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SizeI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SizeI>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SizeI& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SizeI& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SizeI* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.SizeI";
  }
  protected:
  explicit SizeI(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWFieldNumber = 1,
    kHFieldNumber = 2,
  };
  // uint32 w = 1;
  void clear_w();
  uint32_t w() const;
  void set_w(uint32_t value);
  private:
  uint32_t _internal_w() const;
  void _internal_set_w(uint32_t value);
  public:

  // uint32 h = 2;
  void clear_h();
  uint32_t h() const;
  void set_h(uint32_t value);
  private:
  uint32_t _internal_h() const;
  void _internal_set_h(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ratel.SizeI)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t w_;
  uint32_t h_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API SizeF final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.SizeF) */ {
 public:
  inline SizeF() : SizeF(nullptr) {}
  ~SizeF() override;
  explicit PROTOBUF_CONSTEXPR SizeF(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SizeF(const SizeF& from);
  SizeF(SizeF&& from) noexcept
    : SizeF() {
    *this = ::std::move(from);
  }

  inline SizeF& operator=(const SizeF& from) {
    CopyFrom(from);
    return *this;
  }
  inline SizeF& operator=(SizeF&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SizeF& default_instance() {
    return *internal_default_instance();
  }
  static inline const SizeF* internal_default_instance() {
    return reinterpret_cast<const SizeF*>(
               &_SizeF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SizeF& a, SizeF& b) {
    a.Swap(&b);
  }
  inline void Swap(SizeF* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SizeF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SizeF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SizeF>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SizeF& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SizeF& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SizeF* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.SizeF";
  }
  protected:
  explicit SizeF(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWFieldNumber = 1,
    kHFieldNumber = 2,
  };
  // float w = 1;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // float h = 2;
  void clear_h();
  float h() const;
  void set_h(float value);
  private:
  float _internal_h() const;
  void _internal_set_h(float value);
  public:

  // @@protoc_insertion_point(class_scope:ratel.SizeF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float w_;
  float h_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API Line2I final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.Line2I) */ {
 public:
  inline Line2I() : Line2I(nullptr) {}
  ~Line2I() override;
  explicit PROTOBUF_CONSTEXPR Line2I(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Line2I(const Line2I& from);
  Line2I(Line2I&& from) noexcept
    : Line2I() {
    *this = ::std::move(from);
  }

  inline Line2I& operator=(const Line2I& from) {
    CopyFrom(from);
    return *this;
  }
  inline Line2I& operator=(Line2I&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Line2I& default_instance() {
    return *internal_default_instance();
  }
  static inline const Line2I* internal_default_instance() {
    return reinterpret_cast<const Line2I*>(
               &_Line2I_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Line2I& a, Line2I& b) {
    a.Swap(&b);
  }
  inline void Swap(Line2I* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Line2I* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Line2I* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Line2I>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Line2I& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Line2I& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line2I* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.Line2I";
  }
  protected:
  explicit Line2I(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kP0FieldNumber = 1,
    kP1FieldNumber = 2,
  };
  // .ratel.Vec2I p0 = 1;
  bool has_p0() const;
  private:
  bool _internal_has_p0() const;
  public:
  void clear_p0();
  const ::ratel::Vec2I& p0() const;
  PROTOBUF_NODISCARD ::ratel::Vec2I* release_p0();
  ::ratel::Vec2I* mutable_p0();
  void set_allocated_p0(::ratel::Vec2I* p0);
  private:
  const ::ratel::Vec2I& _internal_p0() const;
  ::ratel::Vec2I* _internal_mutable_p0();
  public:
  void unsafe_arena_set_allocated_p0(
      ::ratel::Vec2I* p0);
  ::ratel::Vec2I* unsafe_arena_release_p0();

  // .ratel.Vec2I p1 = 2;
  bool has_p1() const;
  private:
  bool _internal_has_p1() const;
  public:
  void clear_p1();
  const ::ratel::Vec2I& p1() const;
  PROTOBUF_NODISCARD ::ratel::Vec2I* release_p1();
  ::ratel::Vec2I* mutable_p1();
  void set_allocated_p1(::ratel::Vec2I* p1);
  private:
  const ::ratel::Vec2I& _internal_p1() const;
  ::ratel::Vec2I* _internal_mutable_p1();
  public:
  void unsafe_arena_set_allocated_p1(
      ::ratel::Vec2I* p1);
  ::ratel::Vec2I* unsafe_arena_release_p1();

  // @@protoc_insertion_point(class_scope:ratel.Line2I)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ratel::Vec2I* p0_;
  ::ratel::Vec2I* p1_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API Line2F final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.Line2F) */ {
 public:
  inline Line2F() : Line2F(nullptr) {}
  ~Line2F() override;
  explicit PROTOBUF_CONSTEXPR Line2F(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Line2F(const Line2F& from);
  Line2F(Line2F&& from) noexcept
    : Line2F() {
    *this = ::std::move(from);
  }

  inline Line2F& operator=(const Line2F& from) {
    CopyFrom(from);
    return *this;
  }
  inline Line2F& operator=(Line2F&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Line2F& default_instance() {
    return *internal_default_instance();
  }
  static inline const Line2F* internal_default_instance() {
    return reinterpret_cast<const Line2F*>(
               &_Line2F_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Line2F& a, Line2F& b) {
    a.Swap(&b);
  }
  inline void Swap(Line2F* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Line2F* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Line2F* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Line2F>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Line2F& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Line2F& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line2F* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.Line2F";
  }
  protected:
  explicit Line2F(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kP0FieldNumber = 1,
    kP1FieldNumber = 2,
  };
  // .ratel.Vec2F p0 = 1;
  bool has_p0() const;
  private:
  bool _internal_has_p0() const;
  public:
  void clear_p0();
  const ::ratel::Vec2F& p0() const;
  PROTOBUF_NODISCARD ::ratel::Vec2F* release_p0();
  ::ratel::Vec2F* mutable_p0();
  void set_allocated_p0(::ratel::Vec2F* p0);
  private:
  const ::ratel::Vec2F& _internal_p0() const;
  ::ratel::Vec2F* _internal_mutable_p0();
  public:
  void unsafe_arena_set_allocated_p0(
      ::ratel::Vec2F* p0);
  ::ratel::Vec2F* unsafe_arena_release_p0();

  // .ratel.Vec2F p1 = 2;
  bool has_p1() const;
  private:
  bool _internal_has_p1() const;
  public:
  void clear_p1();
  const ::ratel::Vec2F& p1() const;
  PROTOBUF_NODISCARD ::ratel::Vec2F* release_p1();
  ::ratel::Vec2F* mutable_p1();
  void set_allocated_p1(::ratel::Vec2F* p1);
  private:
  const ::ratel::Vec2F& _internal_p1() const;
  ::ratel::Vec2F* _internal_mutable_p1();
  public:
  void unsafe_arena_set_allocated_p1(
      ::ratel::Vec2F* p1);
  ::ratel::Vec2F* unsafe_arena_release_p1();

  // @@protoc_insertion_point(class_scope:ratel.Line2F)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ratel::Vec2F* p0_;
  ::ratel::Vec2F* p1_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API CircleI final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.CircleI) */ {
 public:
  inline CircleI() : CircleI(nullptr) {}
  ~CircleI() override;
  explicit PROTOBUF_CONSTEXPR CircleI(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircleI(const CircleI& from);
  CircleI(CircleI&& from) noexcept
    : CircleI() {
    *this = ::std::move(from);
  }

  inline CircleI& operator=(const CircleI& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircleI& operator=(CircleI&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircleI& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircleI* internal_default_instance() {
    return reinterpret_cast<const CircleI*>(
               &_CircleI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CircleI& a, CircleI& b) {
    a.Swap(&b);
  }
  inline void Swap(CircleI* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircleI* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircleI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircleI>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CircleI& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CircleI& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircleI* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.CircleI";
  }
  protected:
  explicit CircleI(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFieldNumber = 1,
    kRFieldNumber = 2,
  };
  // .ratel.Vec2I center = 1;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::ratel::Vec2I& center() const;
  PROTOBUF_NODISCARD ::ratel::Vec2I* release_center();
  ::ratel::Vec2I* mutable_center();
  void set_allocated_center(::ratel::Vec2I* center);
  private:
  const ::ratel::Vec2I& _internal_center() const;
  ::ratel::Vec2I* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::ratel::Vec2I* center);
  ::ratel::Vec2I* unsafe_arena_release_center();

  // float r = 2;
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // @@protoc_insertion_point(class_scope:ratel.CircleI)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ratel::Vec2I* center_;
  float r_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API CircleF final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.CircleF) */ {
 public:
  inline CircleF() : CircleF(nullptr) {}
  ~CircleF() override;
  explicit PROTOBUF_CONSTEXPR CircleF(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircleF(const CircleF& from);
  CircleF(CircleF&& from) noexcept
    : CircleF() {
    *this = ::std::move(from);
  }

  inline CircleF& operator=(const CircleF& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircleF& operator=(CircleF&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircleF& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircleF* internal_default_instance() {
    return reinterpret_cast<const CircleF*>(
               &_CircleF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CircleF& a, CircleF& b) {
    a.Swap(&b);
  }
  inline void Swap(CircleF* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircleF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircleF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircleF>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CircleF& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CircleF& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircleF* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.CircleF";
  }
  protected:
  explicit CircleF(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFieldNumber = 1,
    kRFieldNumber = 2,
  };
  // .ratel.Vec2F center = 1;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::ratel::Vec2F& center() const;
  PROTOBUF_NODISCARD ::ratel::Vec2F* release_center();
  ::ratel::Vec2F* mutable_center();
  void set_allocated_center(::ratel::Vec2F* center);
  private:
  const ::ratel::Vec2F& _internal_center() const;
  ::ratel::Vec2F* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::ratel::Vec2F* center);
  ::ratel::Vec2F* unsafe_arena_release_center();

  // float r = 2;
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // @@protoc_insertion_point(class_scope:ratel.CircleF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ratel::Vec2F* center_;
  float r_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API RectI final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.RectI) */ {
 public:
  inline RectI() : RectI(nullptr) {}
  ~RectI() override;
  explicit PROTOBUF_CONSTEXPR RectI(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RectI(const RectI& from);
  RectI(RectI&& from) noexcept
    : RectI() {
    *this = ::std::move(from);
  }

  inline RectI& operator=(const RectI& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectI& operator=(RectI&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectI& default_instance() {
    return *internal_default_instance();
  }
  static inline const RectI* internal_default_instance() {
    return reinterpret_cast<const RectI*>(
               &_RectI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RectI& a, RectI& b) {
    a.Swap(&b);
  }
  inline void Swap(RectI* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectI* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RectI>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RectI& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RectI& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RectI* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.RectI";
  }
  protected:
  explicit RectI(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLtFieldNumber = 1,
    kSizeFieldNumber = 2,
    kAngleFieldNumber = 3,
  };
  // .ratel.Vec2I lt = 1;
  bool has_lt() const;
  private:
  bool _internal_has_lt() const;
  public:
  void clear_lt();
  const ::ratel::Vec2I& lt() const;
  PROTOBUF_NODISCARD ::ratel::Vec2I* release_lt();
  ::ratel::Vec2I* mutable_lt();
  void set_allocated_lt(::ratel::Vec2I* lt);
  private:
  const ::ratel::Vec2I& _internal_lt() const;
  ::ratel::Vec2I* _internal_mutable_lt();
  public:
  void unsafe_arena_set_allocated_lt(
      ::ratel::Vec2I* lt);
  ::ratel::Vec2I* unsafe_arena_release_lt();

  // .ratel.SizeI size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::ratel::SizeI& size() const;
  PROTOBUF_NODISCARD ::ratel::SizeI* release_size();
  ::ratel::SizeI* mutable_size();
  void set_allocated_size(::ratel::SizeI* size);
  private:
  const ::ratel::SizeI& _internal_size() const;
  ::ratel::SizeI* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::ratel::SizeI* size);
  ::ratel::SizeI* unsafe_arena_release_size();

  // float angle = 3;
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:ratel.RectI)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ratel::Vec2I* lt_;
  ::ratel::SizeI* size_;
  float angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API RectF final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.RectF) */ {
 public:
  inline RectF() : RectF(nullptr) {}
  ~RectF() override;
  explicit PROTOBUF_CONSTEXPR RectF(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RectF(const RectF& from);
  RectF(RectF&& from) noexcept
    : RectF() {
    *this = ::std::move(from);
  }

  inline RectF& operator=(const RectF& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectF& operator=(RectF&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectF& default_instance() {
    return *internal_default_instance();
  }
  static inline const RectF* internal_default_instance() {
    return reinterpret_cast<const RectF*>(
               &_RectF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RectF& a, RectF& b) {
    a.Swap(&b);
  }
  inline void Swap(RectF* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RectF>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RectF& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RectF& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RectF* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.RectF";
  }
  protected:
  explicit RectF(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLtFieldNumber = 1,
    kSizeFieldNumber = 2,
    kAngleFieldNumber = 3,
  };
  // .ratel.Vec2F lt = 1;
  bool has_lt() const;
  private:
  bool _internal_has_lt() const;
  public:
  void clear_lt();
  const ::ratel::Vec2F& lt() const;
  PROTOBUF_NODISCARD ::ratel::Vec2F* release_lt();
  ::ratel::Vec2F* mutable_lt();
  void set_allocated_lt(::ratel::Vec2F* lt);
  private:
  const ::ratel::Vec2F& _internal_lt() const;
  ::ratel::Vec2F* _internal_mutable_lt();
  public:
  void unsafe_arena_set_allocated_lt(
      ::ratel::Vec2F* lt);
  ::ratel::Vec2F* unsafe_arena_release_lt();

  // .ratel.SizeF size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::ratel::SizeF& size() const;
  PROTOBUF_NODISCARD ::ratel::SizeF* release_size();
  ::ratel::SizeF* mutable_size();
  void set_allocated_size(::ratel::SizeF* size);
  private:
  const ::ratel::SizeF& _internal_size() const;
  ::ratel::SizeF* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::ratel::SizeF* size);
  ::ratel::SizeF* unsafe_arena_release_size();

  // float angle = 3;
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:ratel.RectF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ratel::Vec2F* lt_;
  ::ratel::SizeF* size_;
  float angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API Poly2I final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.Poly2I) */ {
 public:
  inline Poly2I() : Poly2I(nullptr) {}
  ~Poly2I() override;
  explicit PROTOBUF_CONSTEXPR Poly2I(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Poly2I(const Poly2I& from);
  Poly2I(Poly2I&& from) noexcept
    : Poly2I() {
    *this = ::std::move(from);
  }

  inline Poly2I& operator=(const Poly2I& from) {
    CopyFrom(from);
    return *this;
  }
  inline Poly2I& operator=(Poly2I&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Poly2I& default_instance() {
    return *internal_default_instance();
  }
  static inline const Poly2I* internal_default_instance() {
    return reinterpret_cast<const Poly2I*>(
               &_Poly2I_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Poly2I& a, Poly2I& b) {
    a.Swap(&b);
  }
  inline void Swap(Poly2I* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Poly2I* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Poly2I* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Poly2I>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Poly2I& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Poly2I& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Poly2I* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.Poly2I";
  }
  protected:
  explicit Poly2I(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtsFieldNumber = 1,
  };
  // repeated .ratel.Vec2I pts = 1;
  int pts_size() const;
  private:
  int _internal_pts_size() const;
  public:
  void clear_pts();
  ::ratel::Vec2I* mutable_pts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2I >*
      mutable_pts();
  private:
  const ::ratel::Vec2I& _internal_pts(int index) const;
  ::ratel::Vec2I* _internal_add_pts();
  public:
  const ::ratel::Vec2I& pts(int index) const;
  ::ratel::Vec2I* add_pts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2I >&
      pts() const;

  // @@protoc_insertion_point(class_scope:ratel.Poly2I)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2I > pts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class RATEL_GEOMETRY_API Poly2F final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ratel.Poly2F) */ {
 public:
  inline Poly2F() : Poly2F(nullptr) {}
  ~Poly2F() override;
  explicit PROTOBUF_CONSTEXPR Poly2F(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Poly2F(const Poly2F& from);
  Poly2F(Poly2F&& from) noexcept
    : Poly2F() {
    *this = ::std::move(from);
  }

  inline Poly2F& operator=(const Poly2F& from) {
    CopyFrom(from);
    return *this;
  }
  inline Poly2F& operator=(Poly2F&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Poly2F& default_instance() {
    return *internal_default_instance();
  }
  static inline const Poly2F* internal_default_instance() {
    return reinterpret_cast<const Poly2F*>(
               &_Poly2F_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Poly2F& a, Poly2F& b) {
    a.Swap(&b);
  }
  inline void Swap(Poly2F* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Poly2F* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Poly2F* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Poly2F>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Poly2F& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Poly2F& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Poly2F* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ratel.Poly2F";
  }
  protected:
  explicit Poly2F(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtsFieldNumber = 1,
  };
  // repeated .ratel.Vec2F pts = 1;
  int pts_size() const;
  private:
  int _internal_pts_size() const;
  public:
  void clear_pts();
  ::ratel::Vec2F* mutable_pts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2F >*
      mutable_pts();
  private:
  const ::ratel::Vec2F& _internal_pts(int index) const;
  ::ratel::Vec2F* _internal_add_pts();
  public:
  const ::ratel::Vec2F& pts(int index) const;
  ::ratel::Vec2F* add_pts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2F >&
      pts() const;

  // @@protoc_insertion_point(class_scope:ratel.Poly2F)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2F > pts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec2F

// float x = 1;
inline void Vec2F::clear_x() {
  x_ = 0;
}
inline float Vec2F::_internal_x() const {
  return x_;
}
inline float Vec2F::x() const {
  // @@protoc_insertion_point(field_get:ratel.Vec2F.x)
  return _internal_x();
}
inline void Vec2F::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vec2F::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ratel.Vec2F.x)
}

// float y = 2;
inline void Vec2F::clear_y() {
  y_ = 0;
}
inline float Vec2F::_internal_y() const {
  return y_;
}
inline float Vec2F::y() const {
  // @@protoc_insertion_point(field_get:ratel.Vec2F.y)
  return _internal_y();
}
inline void Vec2F::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vec2F::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ratel.Vec2F.y)
}

// -------------------------------------------------------------------

// Vec2fList

// repeated .ratel.Vec2F list = 1;
inline int Vec2fList::_internal_list_size() const {
  return list_.size();
}
inline int Vec2fList::list_size() const {
  return _internal_list_size();
}
inline void Vec2fList::clear_list() {
  list_.Clear();
}
inline ::ratel::Vec2F* Vec2fList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:ratel.Vec2fList.list)
  return list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2F >*
Vec2fList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:ratel.Vec2fList.list)
  return &list_;
}
inline const ::ratel::Vec2F& Vec2fList::_internal_list(int index) const {
  return list_.Get(index);
}
inline const ::ratel::Vec2F& Vec2fList::list(int index) const {
  // @@protoc_insertion_point(field_get:ratel.Vec2fList.list)
  return _internal_list(index);
}
inline ::ratel::Vec2F* Vec2fList::_internal_add_list() {
  return list_.Add();
}
inline ::ratel::Vec2F* Vec2fList::add_list() {
  ::ratel::Vec2F* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:ratel.Vec2fList.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2F >&
Vec2fList::list() const {
  // @@protoc_insertion_point(field_list:ratel.Vec2fList.list)
  return list_;
}

// -------------------------------------------------------------------

// Vec2I

// int32 x = 1;
inline void Vec2I::clear_x() {
  x_ = 0;
}
inline int32_t Vec2I::_internal_x() const {
  return x_;
}
inline int32_t Vec2I::x() const {
  // @@protoc_insertion_point(field_get:ratel.Vec2I.x)
  return _internal_x();
}
inline void Vec2I::_internal_set_x(int32_t value) {
  
  x_ = value;
}
inline void Vec2I::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ratel.Vec2I.x)
}

// int32 y = 2;
inline void Vec2I::clear_y() {
  y_ = 0;
}
inline int32_t Vec2I::_internal_y() const {
  return y_;
}
inline int32_t Vec2I::y() const {
  // @@protoc_insertion_point(field_get:ratel.Vec2I.y)
  return _internal_y();
}
inline void Vec2I::_internal_set_y(int32_t value) {
  
  y_ = value;
}
inline void Vec2I::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ratel.Vec2I.y)
}

// -------------------------------------------------------------------

// Vec3F

// float x = 1;
inline void Vec3F::clear_x() {
  x_ = 0;
}
inline float Vec3F::_internal_x() const {
  return x_;
}
inline float Vec3F::x() const {
  // @@protoc_insertion_point(field_get:ratel.Vec3F.x)
  return _internal_x();
}
inline void Vec3F::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vec3F::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ratel.Vec3F.x)
}

// float y = 2;
inline void Vec3F::clear_y() {
  y_ = 0;
}
inline float Vec3F::_internal_y() const {
  return y_;
}
inline float Vec3F::y() const {
  // @@protoc_insertion_point(field_get:ratel.Vec3F.y)
  return _internal_y();
}
inline void Vec3F::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vec3F::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ratel.Vec3F.y)
}

// float z = 3;
inline void Vec3F::clear_z() {
  z_ = 0;
}
inline float Vec3F::_internal_z() const {
  return z_;
}
inline float Vec3F::z() const {
  // @@protoc_insertion_point(field_get:ratel.Vec3F.z)
  return _internal_z();
}
inline void Vec3F::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Vec3F::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:ratel.Vec3F.z)
}

// -------------------------------------------------------------------

// Vec3I

// int32 x = 1;
inline void Vec3I::clear_x() {
  x_ = 0;
}
inline int32_t Vec3I::_internal_x() const {
  return x_;
}
inline int32_t Vec3I::x() const {
  // @@protoc_insertion_point(field_get:ratel.Vec3I.x)
  return _internal_x();
}
inline void Vec3I::_internal_set_x(int32_t value) {
  
  x_ = value;
}
inline void Vec3I::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ratel.Vec3I.x)
}

// int32 y = 2;
inline void Vec3I::clear_y() {
  y_ = 0;
}
inline int32_t Vec3I::_internal_y() const {
  return y_;
}
inline int32_t Vec3I::y() const {
  // @@protoc_insertion_point(field_get:ratel.Vec3I.y)
  return _internal_y();
}
inline void Vec3I::_internal_set_y(int32_t value) {
  
  y_ = value;
}
inline void Vec3I::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ratel.Vec3I.y)
}

// int32 z = 3;
inline void Vec3I::clear_z() {
  z_ = 0;
}
inline int32_t Vec3I::_internal_z() const {
  return z_;
}
inline int32_t Vec3I::z() const {
  // @@protoc_insertion_point(field_get:ratel.Vec3I.z)
  return _internal_z();
}
inline void Vec3I::_internal_set_z(int32_t value) {
  
  z_ = value;
}
inline void Vec3I::set_z(int32_t value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:ratel.Vec3I.z)
}

// -------------------------------------------------------------------

// SizeI

// uint32 w = 1;
inline void SizeI::clear_w() {
  w_ = 0u;
}
inline uint32_t SizeI::_internal_w() const {
  return w_;
}
inline uint32_t SizeI::w() const {
  // @@protoc_insertion_point(field_get:ratel.SizeI.w)
  return _internal_w();
}
inline void SizeI::_internal_set_w(uint32_t value) {
  
  w_ = value;
}
inline void SizeI::set_w(uint32_t value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:ratel.SizeI.w)
}

// uint32 h = 2;
inline void SizeI::clear_h() {
  h_ = 0u;
}
inline uint32_t SizeI::_internal_h() const {
  return h_;
}
inline uint32_t SizeI::h() const {
  // @@protoc_insertion_point(field_get:ratel.SizeI.h)
  return _internal_h();
}
inline void SizeI::_internal_set_h(uint32_t value) {
  
  h_ = value;
}
inline void SizeI::set_h(uint32_t value) {
  _internal_set_h(value);
  // @@protoc_insertion_point(field_set:ratel.SizeI.h)
}

// -------------------------------------------------------------------

// SizeF

// float w = 1;
inline void SizeF::clear_w() {
  w_ = 0;
}
inline float SizeF::_internal_w() const {
  return w_;
}
inline float SizeF::w() const {
  // @@protoc_insertion_point(field_get:ratel.SizeF.w)
  return _internal_w();
}
inline void SizeF::_internal_set_w(float value) {
  
  w_ = value;
}
inline void SizeF::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:ratel.SizeF.w)
}

// float h = 2;
inline void SizeF::clear_h() {
  h_ = 0;
}
inline float SizeF::_internal_h() const {
  return h_;
}
inline float SizeF::h() const {
  // @@protoc_insertion_point(field_get:ratel.SizeF.h)
  return _internal_h();
}
inline void SizeF::_internal_set_h(float value) {
  
  h_ = value;
}
inline void SizeF::set_h(float value) {
  _internal_set_h(value);
  // @@protoc_insertion_point(field_set:ratel.SizeF.h)
}

// -------------------------------------------------------------------

// Line2I

// .ratel.Vec2I p0 = 1;
inline bool Line2I::_internal_has_p0() const {
  return this != internal_default_instance() && p0_ != nullptr;
}
inline bool Line2I::has_p0() const {
  return _internal_has_p0();
}
inline void Line2I::clear_p0() {
  if (GetArenaForAllocation() == nullptr && p0_ != nullptr) {
    delete p0_;
  }
  p0_ = nullptr;
}
inline const ::ratel::Vec2I& Line2I::_internal_p0() const {
  const ::ratel::Vec2I* p = p0_;
  return p != nullptr ? *p : reinterpret_cast<const ::ratel::Vec2I&>(
      ::ratel::_Vec2I_default_instance_);
}
inline const ::ratel::Vec2I& Line2I::p0() const {
  // @@protoc_insertion_point(field_get:ratel.Line2I.p0)
  return _internal_p0();
}
inline void Line2I::unsafe_arena_set_allocated_p0(
    ::ratel::Vec2I* p0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p0_);
  }
  p0_ = p0;
  if (p0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ratel.Line2I.p0)
}
inline ::ratel::Vec2I* Line2I::release_p0() {
  
  ::ratel::Vec2I* temp = p0_;
  p0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ratel::Vec2I* Line2I::unsafe_arena_release_p0() {
  // @@protoc_insertion_point(field_release:ratel.Line2I.p0)
  
  ::ratel::Vec2I* temp = p0_;
  p0_ = nullptr;
  return temp;
}
inline ::ratel::Vec2I* Line2I::_internal_mutable_p0() {
  
  if (p0_ == nullptr) {
    auto* p = CreateMaybeMessage<::ratel::Vec2I>(GetArenaForAllocation());
    p0_ = p;
  }
  return p0_;
}
inline ::ratel::Vec2I* Line2I::mutable_p0() {
  ::ratel::Vec2I* _msg = _internal_mutable_p0();
  // @@protoc_insertion_point(field_mutable:ratel.Line2I.p0)
  return _msg;
}
inline void Line2I::set_allocated_p0(::ratel::Vec2I* p0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete p0_;
  }
  if (p0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(p0);
    if (message_arena != submessage_arena) {
      p0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p0, submessage_arena);
    }
    
  } else {
    
  }
  p0_ = p0;
  // @@protoc_insertion_point(field_set_allocated:ratel.Line2I.p0)
}

// .ratel.Vec2I p1 = 2;
inline bool Line2I::_internal_has_p1() const {
  return this != internal_default_instance() && p1_ != nullptr;
}
inline bool Line2I::has_p1() const {
  return _internal_has_p1();
}
inline void Line2I::clear_p1() {
  if (GetArenaForAllocation() == nullptr && p1_ != nullptr) {
    delete p1_;
  }
  p1_ = nullptr;
}
inline const ::ratel::Vec2I& Line2I::_internal_p1() const {
  const ::ratel::Vec2I* p = p1_;
  return p != nullptr ? *p : reinterpret_cast<const ::ratel::Vec2I&>(
      ::ratel::_Vec2I_default_instance_);
}
inline const ::ratel::Vec2I& Line2I::p1() const {
  // @@protoc_insertion_point(field_get:ratel.Line2I.p1)
  return _internal_p1();
}
inline void Line2I::unsafe_arena_set_allocated_p1(
    ::ratel::Vec2I* p1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p1_);
  }
  p1_ = p1;
  if (p1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ratel.Line2I.p1)
}
inline ::ratel::Vec2I* Line2I::release_p1() {
  
  ::ratel::Vec2I* temp = p1_;
  p1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ratel::Vec2I* Line2I::unsafe_arena_release_p1() {
  // @@protoc_insertion_point(field_release:ratel.Line2I.p1)
  
  ::ratel::Vec2I* temp = p1_;
  p1_ = nullptr;
  return temp;
}
inline ::ratel::Vec2I* Line2I::_internal_mutable_p1() {
  
  if (p1_ == nullptr) {
    auto* p = CreateMaybeMessage<::ratel::Vec2I>(GetArenaForAllocation());
    p1_ = p;
  }
  return p1_;
}
inline ::ratel::Vec2I* Line2I::mutable_p1() {
  ::ratel::Vec2I* _msg = _internal_mutable_p1();
  // @@protoc_insertion_point(field_mutable:ratel.Line2I.p1)
  return _msg;
}
inline void Line2I::set_allocated_p1(::ratel::Vec2I* p1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete p1_;
  }
  if (p1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(p1);
    if (message_arena != submessage_arena) {
      p1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p1, submessage_arena);
    }
    
  } else {
    
  }
  p1_ = p1;
  // @@protoc_insertion_point(field_set_allocated:ratel.Line2I.p1)
}

// -------------------------------------------------------------------

// Line2F

// .ratel.Vec2F p0 = 1;
inline bool Line2F::_internal_has_p0() const {
  return this != internal_default_instance() && p0_ != nullptr;
}
inline bool Line2F::has_p0() const {
  return _internal_has_p0();
}
inline void Line2F::clear_p0() {
  if (GetArenaForAllocation() == nullptr && p0_ != nullptr) {
    delete p0_;
  }
  p0_ = nullptr;
}
inline const ::ratel::Vec2F& Line2F::_internal_p0() const {
  const ::ratel::Vec2F* p = p0_;
  return p != nullptr ? *p : reinterpret_cast<const ::ratel::Vec2F&>(
      ::ratel::_Vec2F_default_instance_);
}
inline const ::ratel::Vec2F& Line2F::p0() const {
  // @@protoc_insertion_point(field_get:ratel.Line2F.p0)
  return _internal_p0();
}
inline void Line2F::unsafe_arena_set_allocated_p0(
    ::ratel::Vec2F* p0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p0_);
  }
  p0_ = p0;
  if (p0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ratel.Line2F.p0)
}
inline ::ratel::Vec2F* Line2F::release_p0() {
  
  ::ratel::Vec2F* temp = p0_;
  p0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ratel::Vec2F* Line2F::unsafe_arena_release_p0() {
  // @@protoc_insertion_point(field_release:ratel.Line2F.p0)
  
  ::ratel::Vec2F* temp = p0_;
  p0_ = nullptr;
  return temp;
}
inline ::ratel::Vec2F* Line2F::_internal_mutable_p0() {
  
  if (p0_ == nullptr) {
    auto* p = CreateMaybeMessage<::ratel::Vec2F>(GetArenaForAllocation());
    p0_ = p;
  }
  return p0_;
}
inline ::ratel::Vec2F* Line2F::mutable_p0() {
  ::ratel::Vec2F* _msg = _internal_mutable_p0();
  // @@protoc_insertion_point(field_mutable:ratel.Line2F.p0)
  return _msg;
}
inline void Line2F::set_allocated_p0(::ratel::Vec2F* p0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete p0_;
  }
  if (p0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(p0);
    if (message_arena != submessage_arena) {
      p0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p0, submessage_arena);
    }
    
  } else {
    
  }
  p0_ = p0;
  // @@protoc_insertion_point(field_set_allocated:ratel.Line2F.p0)
}

// .ratel.Vec2F p1 = 2;
inline bool Line2F::_internal_has_p1() const {
  return this != internal_default_instance() && p1_ != nullptr;
}
inline bool Line2F::has_p1() const {
  return _internal_has_p1();
}
inline void Line2F::clear_p1() {
  if (GetArenaForAllocation() == nullptr && p1_ != nullptr) {
    delete p1_;
  }
  p1_ = nullptr;
}
inline const ::ratel::Vec2F& Line2F::_internal_p1() const {
  const ::ratel::Vec2F* p = p1_;
  return p != nullptr ? *p : reinterpret_cast<const ::ratel::Vec2F&>(
      ::ratel::_Vec2F_default_instance_);
}
inline const ::ratel::Vec2F& Line2F::p1() const {
  // @@protoc_insertion_point(field_get:ratel.Line2F.p1)
  return _internal_p1();
}
inline void Line2F::unsafe_arena_set_allocated_p1(
    ::ratel::Vec2F* p1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p1_);
  }
  p1_ = p1;
  if (p1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ratel.Line2F.p1)
}
inline ::ratel::Vec2F* Line2F::release_p1() {
  
  ::ratel::Vec2F* temp = p1_;
  p1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ratel::Vec2F* Line2F::unsafe_arena_release_p1() {
  // @@protoc_insertion_point(field_release:ratel.Line2F.p1)
  
  ::ratel::Vec2F* temp = p1_;
  p1_ = nullptr;
  return temp;
}
inline ::ratel::Vec2F* Line2F::_internal_mutable_p1() {
  
  if (p1_ == nullptr) {
    auto* p = CreateMaybeMessage<::ratel::Vec2F>(GetArenaForAllocation());
    p1_ = p;
  }
  return p1_;
}
inline ::ratel::Vec2F* Line2F::mutable_p1() {
  ::ratel::Vec2F* _msg = _internal_mutable_p1();
  // @@protoc_insertion_point(field_mutable:ratel.Line2F.p1)
  return _msg;
}
inline void Line2F::set_allocated_p1(::ratel::Vec2F* p1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete p1_;
  }
  if (p1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(p1);
    if (message_arena != submessage_arena) {
      p1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p1, submessage_arena);
    }
    
  } else {
    
  }
  p1_ = p1;
  // @@protoc_insertion_point(field_set_allocated:ratel.Line2F.p1)
}

// -------------------------------------------------------------------

// CircleI

// .ratel.Vec2I center = 1;
inline bool CircleI::_internal_has_center() const {
  return this != internal_default_instance() && center_ != nullptr;
}
inline bool CircleI::has_center() const {
  return _internal_has_center();
}
inline void CircleI::clear_center() {
  if (GetArenaForAllocation() == nullptr && center_ != nullptr) {
    delete center_;
  }
  center_ = nullptr;
}
inline const ::ratel::Vec2I& CircleI::_internal_center() const {
  const ::ratel::Vec2I* p = center_;
  return p != nullptr ? *p : reinterpret_cast<const ::ratel::Vec2I&>(
      ::ratel::_Vec2I_default_instance_);
}
inline const ::ratel::Vec2I& CircleI::center() const {
  // @@protoc_insertion_point(field_get:ratel.CircleI.center)
  return _internal_center();
}
inline void CircleI::unsafe_arena_set_allocated_center(
    ::ratel::Vec2I* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  center_ = center;
  if (center) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ratel.CircleI.center)
}
inline ::ratel::Vec2I* CircleI::release_center() {
  
  ::ratel::Vec2I* temp = center_;
  center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ratel::Vec2I* CircleI::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:ratel.CircleI.center)
  
  ::ratel::Vec2I* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::ratel::Vec2I* CircleI::_internal_mutable_center() {
  
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::ratel::Vec2I>(GetArenaForAllocation());
    center_ = p;
  }
  return center_;
}
inline ::ratel::Vec2I* CircleI::mutable_center() {
  ::ratel::Vec2I* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:ratel.CircleI.center)
  return _msg;
}
inline void CircleI::set_allocated_center(::ratel::Vec2I* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:ratel.CircleI.center)
}

// float r = 2;
inline void CircleI::clear_r() {
  r_ = 0;
}
inline float CircleI::_internal_r() const {
  return r_;
}
inline float CircleI::r() const {
  // @@protoc_insertion_point(field_get:ratel.CircleI.r)
  return _internal_r();
}
inline void CircleI::_internal_set_r(float value) {
  
  r_ = value;
}
inline void CircleI::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:ratel.CircleI.r)
}

// -------------------------------------------------------------------

// CircleF

// .ratel.Vec2F center = 1;
inline bool CircleF::_internal_has_center() const {
  return this != internal_default_instance() && center_ != nullptr;
}
inline bool CircleF::has_center() const {
  return _internal_has_center();
}
inline void CircleF::clear_center() {
  if (GetArenaForAllocation() == nullptr && center_ != nullptr) {
    delete center_;
  }
  center_ = nullptr;
}
inline const ::ratel::Vec2F& CircleF::_internal_center() const {
  const ::ratel::Vec2F* p = center_;
  return p != nullptr ? *p : reinterpret_cast<const ::ratel::Vec2F&>(
      ::ratel::_Vec2F_default_instance_);
}
inline const ::ratel::Vec2F& CircleF::center() const {
  // @@protoc_insertion_point(field_get:ratel.CircleF.center)
  return _internal_center();
}
inline void CircleF::unsafe_arena_set_allocated_center(
    ::ratel::Vec2F* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  center_ = center;
  if (center) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ratel.CircleF.center)
}
inline ::ratel::Vec2F* CircleF::release_center() {
  
  ::ratel::Vec2F* temp = center_;
  center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ratel::Vec2F* CircleF::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:ratel.CircleF.center)
  
  ::ratel::Vec2F* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::ratel::Vec2F* CircleF::_internal_mutable_center() {
  
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::ratel::Vec2F>(GetArenaForAllocation());
    center_ = p;
  }
  return center_;
}
inline ::ratel::Vec2F* CircleF::mutable_center() {
  ::ratel::Vec2F* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:ratel.CircleF.center)
  return _msg;
}
inline void CircleF::set_allocated_center(::ratel::Vec2F* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:ratel.CircleF.center)
}

// float r = 2;
inline void CircleF::clear_r() {
  r_ = 0;
}
inline float CircleF::_internal_r() const {
  return r_;
}
inline float CircleF::r() const {
  // @@protoc_insertion_point(field_get:ratel.CircleF.r)
  return _internal_r();
}
inline void CircleF::_internal_set_r(float value) {
  
  r_ = value;
}
inline void CircleF::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:ratel.CircleF.r)
}

// -------------------------------------------------------------------

// RectI

// .ratel.Vec2I lt = 1;
inline bool RectI::_internal_has_lt() const {
  return this != internal_default_instance() && lt_ != nullptr;
}
inline bool RectI::has_lt() const {
  return _internal_has_lt();
}
inline void RectI::clear_lt() {
  if (GetArenaForAllocation() == nullptr && lt_ != nullptr) {
    delete lt_;
  }
  lt_ = nullptr;
}
inline const ::ratel::Vec2I& RectI::_internal_lt() const {
  const ::ratel::Vec2I* p = lt_;
  return p != nullptr ? *p : reinterpret_cast<const ::ratel::Vec2I&>(
      ::ratel::_Vec2I_default_instance_);
}
inline const ::ratel::Vec2I& RectI::lt() const {
  // @@protoc_insertion_point(field_get:ratel.RectI.lt)
  return _internal_lt();
}
inline void RectI::unsafe_arena_set_allocated_lt(
    ::ratel::Vec2I* lt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lt_);
  }
  lt_ = lt;
  if (lt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ratel.RectI.lt)
}
inline ::ratel::Vec2I* RectI::release_lt() {
  
  ::ratel::Vec2I* temp = lt_;
  lt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ratel::Vec2I* RectI::unsafe_arena_release_lt() {
  // @@protoc_insertion_point(field_release:ratel.RectI.lt)
  
  ::ratel::Vec2I* temp = lt_;
  lt_ = nullptr;
  return temp;
}
inline ::ratel::Vec2I* RectI::_internal_mutable_lt() {
  
  if (lt_ == nullptr) {
    auto* p = CreateMaybeMessage<::ratel::Vec2I>(GetArenaForAllocation());
    lt_ = p;
  }
  return lt_;
}
inline ::ratel::Vec2I* RectI::mutable_lt() {
  ::ratel::Vec2I* _msg = _internal_mutable_lt();
  // @@protoc_insertion_point(field_mutable:ratel.RectI.lt)
  return _msg;
}
inline void RectI::set_allocated_lt(::ratel::Vec2I* lt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lt_;
  }
  if (lt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lt);
    if (message_arena != submessage_arena) {
      lt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lt, submessage_arena);
    }
    
  } else {
    
  }
  lt_ = lt;
  // @@protoc_insertion_point(field_set_allocated:ratel.RectI.lt)
}

// .ratel.SizeI size = 2;
inline bool RectI::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool RectI::has_size() const {
  return _internal_has_size();
}
inline void RectI::clear_size() {
  if (GetArenaForAllocation() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::ratel::SizeI& RectI::_internal_size() const {
  const ::ratel::SizeI* p = size_;
  return p != nullptr ? *p : reinterpret_cast<const ::ratel::SizeI&>(
      ::ratel::_SizeI_default_instance_);
}
inline const ::ratel::SizeI& RectI::size() const {
  // @@protoc_insertion_point(field_get:ratel.RectI.size)
  return _internal_size();
}
inline void RectI::unsafe_arena_set_allocated_size(
    ::ratel::SizeI* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ratel.RectI.size)
}
inline ::ratel::SizeI* RectI::release_size() {
  
  ::ratel::SizeI* temp = size_;
  size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ratel::SizeI* RectI::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:ratel.RectI.size)
  
  ::ratel::SizeI* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::ratel::SizeI* RectI::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::ratel::SizeI>(GetArenaForAllocation());
    size_ = p;
  }
  return size_;
}
inline ::ratel::SizeI* RectI::mutable_size() {
  ::ratel::SizeI* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:ratel.RectI.size)
  return _msg;
}
inline void RectI::set_allocated_size(::ratel::SizeI* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:ratel.RectI.size)
}

// float angle = 3;
inline void RectI::clear_angle() {
  angle_ = 0;
}
inline float RectI::_internal_angle() const {
  return angle_;
}
inline float RectI::angle() const {
  // @@protoc_insertion_point(field_get:ratel.RectI.angle)
  return _internal_angle();
}
inline void RectI::_internal_set_angle(float value) {
  
  angle_ = value;
}
inline void RectI::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:ratel.RectI.angle)
}

// -------------------------------------------------------------------

// RectF

// .ratel.Vec2F lt = 1;
inline bool RectF::_internal_has_lt() const {
  return this != internal_default_instance() && lt_ != nullptr;
}
inline bool RectF::has_lt() const {
  return _internal_has_lt();
}
inline void RectF::clear_lt() {
  if (GetArenaForAllocation() == nullptr && lt_ != nullptr) {
    delete lt_;
  }
  lt_ = nullptr;
}
inline const ::ratel::Vec2F& RectF::_internal_lt() const {
  const ::ratel::Vec2F* p = lt_;
  return p != nullptr ? *p : reinterpret_cast<const ::ratel::Vec2F&>(
      ::ratel::_Vec2F_default_instance_);
}
inline const ::ratel::Vec2F& RectF::lt() const {
  // @@protoc_insertion_point(field_get:ratel.RectF.lt)
  return _internal_lt();
}
inline void RectF::unsafe_arena_set_allocated_lt(
    ::ratel::Vec2F* lt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lt_);
  }
  lt_ = lt;
  if (lt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ratel.RectF.lt)
}
inline ::ratel::Vec2F* RectF::release_lt() {
  
  ::ratel::Vec2F* temp = lt_;
  lt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ratel::Vec2F* RectF::unsafe_arena_release_lt() {
  // @@protoc_insertion_point(field_release:ratel.RectF.lt)
  
  ::ratel::Vec2F* temp = lt_;
  lt_ = nullptr;
  return temp;
}
inline ::ratel::Vec2F* RectF::_internal_mutable_lt() {
  
  if (lt_ == nullptr) {
    auto* p = CreateMaybeMessage<::ratel::Vec2F>(GetArenaForAllocation());
    lt_ = p;
  }
  return lt_;
}
inline ::ratel::Vec2F* RectF::mutable_lt() {
  ::ratel::Vec2F* _msg = _internal_mutable_lt();
  // @@protoc_insertion_point(field_mutable:ratel.RectF.lt)
  return _msg;
}
inline void RectF::set_allocated_lt(::ratel::Vec2F* lt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lt_;
  }
  if (lt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lt);
    if (message_arena != submessage_arena) {
      lt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lt, submessage_arena);
    }
    
  } else {
    
  }
  lt_ = lt;
  // @@protoc_insertion_point(field_set_allocated:ratel.RectF.lt)
}

// .ratel.SizeF size = 2;
inline bool RectF::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool RectF::has_size() const {
  return _internal_has_size();
}
inline void RectF::clear_size() {
  if (GetArenaForAllocation() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::ratel::SizeF& RectF::_internal_size() const {
  const ::ratel::SizeF* p = size_;
  return p != nullptr ? *p : reinterpret_cast<const ::ratel::SizeF&>(
      ::ratel::_SizeF_default_instance_);
}
inline const ::ratel::SizeF& RectF::size() const {
  // @@protoc_insertion_point(field_get:ratel.RectF.size)
  return _internal_size();
}
inline void RectF::unsafe_arena_set_allocated_size(
    ::ratel::SizeF* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ratel.RectF.size)
}
inline ::ratel::SizeF* RectF::release_size() {
  
  ::ratel::SizeF* temp = size_;
  size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ratel::SizeF* RectF::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:ratel.RectF.size)
  
  ::ratel::SizeF* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::ratel::SizeF* RectF::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::ratel::SizeF>(GetArenaForAllocation());
    size_ = p;
  }
  return size_;
}
inline ::ratel::SizeF* RectF::mutable_size() {
  ::ratel::SizeF* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:ratel.RectF.size)
  return _msg;
}
inline void RectF::set_allocated_size(::ratel::SizeF* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:ratel.RectF.size)
}

// float angle = 3;
inline void RectF::clear_angle() {
  angle_ = 0;
}
inline float RectF::_internal_angle() const {
  return angle_;
}
inline float RectF::angle() const {
  // @@protoc_insertion_point(field_get:ratel.RectF.angle)
  return _internal_angle();
}
inline void RectF::_internal_set_angle(float value) {
  
  angle_ = value;
}
inline void RectF::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:ratel.RectF.angle)
}

// -------------------------------------------------------------------

// Poly2I

// repeated .ratel.Vec2I pts = 1;
inline int Poly2I::_internal_pts_size() const {
  return pts_.size();
}
inline int Poly2I::pts_size() const {
  return _internal_pts_size();
}
inline void Poly2I::clear_pts() {
  pts_.Clear();
}
inline ::ratel::Vec2I* Poly2I::mutable_pts(int index) {
  // @@protoc_insertion_point(field_mutable:ratel.Poly2I.pts)
  return pts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2I >*
Poly2I::mutable_pts() {
  // @@protoc_insertion_point(field_mutable_list:ratel.Poly2I.pts)
  return &pts_;
}
inline const ::ratel::Vec2I& Poly2I::_internal_pts(int index) const {
  return pts_.Get(index);
}
inline const ::ratel::Vec2I& Poly2I::pts(int index) const {
  // @@protoc_insertion_point(field_get:ratel.Poly2I.pts)
  return _internal_pts(index);
}
inline ::ratel::Vec2I* Poly2I::_internal_add_pts() {
  return pts_.Add();
}
inline ::ratel::Vec2I* Poly2I::add_pts() {
  ::ratel::Vec2I* _add = _internal_add_pts();
  // @@protoc_insertion_point(field_add:ratel.Poly2I.pts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2I >&
Poly2I::pts() const {
  // @@protoc_insertion_point(field_list:ratel.Poly2I.pts)
  return pts_;
}

// -------------------------------------------------------------------

// Poly2F

// repeated .ratel.Vec2F pts = 1;
inline int Poly2F::_internal_pts_size() const {
  return pts_.size();
}
inline int Poly2F::pts_size() const {
  return _internal_pts_size();
}
inline void Poly2F::clear_pts() {
  pts_.Clear();
}
inline ::ratel::Vec2F* Poly2F::mutable_pts(int index) {
  // @@protoc_insertion_point(field_mutable:ratel.Poly2F.pts)
  return pts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2F >*
Poly2F::mutable_pts() {
  // @@protoc_insertion_point(field_mutable_list:ratel.Poly2F.pts)
  return &pts_;
}
inline const ::ratel::Vec2F& Poly2F::_internal_pts(int index) const {
  return pts_.Get(index);
}
inline const ::ratel::Vec2F& Poly2F::pts(int index) const {
  // @@protoc_insertion_point(field_get:ratel.Poly2F.pts)
  return _internal_pts(index);
}
inline ::ratel::Vec2F* Poly2F::_internal_add_pts() {
  return pts_.Add();
}
inline ::ratel::Vec2F* Poly2F::add_pts() {
  ::ratel::Vec2F* _add = _internal_add_pts();
  // @@protoc_insertion_point(field_add:ratel.Poly2F.pts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ratel::Vec2F >&
Poly2F::pts() const {
  // @@protoc_insertion_point(field_list:ratel.Poly2F.pts)
  return pts_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ratel

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_geometry_2eproto
